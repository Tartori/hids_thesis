\section{Examples}
\label{sec:Exaples}

In this section I will give some general usecases and the configuration that would be used. This is to make it easier to understand the \gls{hids} and how it can be used. I will mainly use the apache webserver as an example. There will be some assumptions on the directories and contents for both scenarios. Additionally I assume that the file system is accessible through `/dev/sda1' 

For additional help there is also a user documentation in apendix section \ref{sec:userdocu}

\subsection{Webpage hosted in Apache}

For those examples I will take the assumption that the apache webserver is installed and has a htdocs directory that is located in `/var/www/'. I assume that there is a webpage running with some php files. It also has html, css, javascript and image files in a static folder. Then it has a log directory where the webpage itself stores all the logs and an upload directory where the user can upload all kind of files. There are 4 types of files that are watched, some more and some less closely. Example Configurations will be given for each type. For the scanner config the config in listing \ref{lst:example:scanner} can be used.

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:scanner]

sqlite:
    filename: apache.db

scan:
    image_path: /dev/sda1
    scan_paths: 
        [
            "/var/www/htdocs/",
        ]

\end{lstlisting}

\subsubsection{PHP files}

The webserver has some php files in different directories. Those are used for varios purposes, but they should never change, except for an update to the webpage. All of them lie in some subdirectory of the htdocs directory. Thus they all are covered in the scan from the configuration in listing \ref{lst:example:scanner}. 

The tricky part is, that we have multiple different php files in different directories. The configuration should cover that even if the exact location and folder structure changes a bit and new folder are added. As the scanner automatically scans recursively, the exact folder structure does not really matter. The files will be found when they are in the htdocs directory. As the files should not change but might be accessed at any time, watching everything should be what we want. Especially important are the modified, changed and created times. Also important are size, path, name and inode.

This much for the rule, the investigation is then relatively easy. There is not a special path that has to be watched since the scanner was configured only to scan htdocs. By using the same database, the investigator will only validate this data as well. Important though is the whitelist. There is an upload directory in which we expect changes. Thus a file name regex of `.php\$' will only validate php files.

An example investigator configuration is listed in listing \ref{lst:example:php}. For this configuration I did not use the preconfigured rules.

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:php]
sqlite:
    filename: apache.db

investigator:
    same_config: True
    rules: 
        - name: equal_but_accessible
        equal:
            - meta_creation_time
            - meta_creation_time_nano
            - meta_modification_time
            - meta_modification_time_nano
            - meta_changed_time
            - meta_changed_time_nano
            - meta_size
            - path
            - meta_addr
            - name_name
        greater:
            - meta_access_time
        investigations:
            - fileregexwhitelist: '.php$'
              rules:
                - equal_but_accessible
\end{lstlisting}

\subsubsection{Upload directory}

As already mentioned, there is an upload directory. This is more tricky, since there files might get upladed and deleted all the time. What we do care about is that there are no php files uploaded. This way an intruder could create a reverse shell in the browser. That would be very bad and we definitely want to detect that with every scan even. It would be cought with the rule from listing \ref{lst:example:php} because this scanns for all php files. However, as an exercise and even just to ensure it is actually caught there is another rule for the upload directory.

For the rule we definitely need to add the special rules `new\_files\_ok' and `deleted\_files\_ok' since both is actually ok. Then generally greater access and modification times are ok. For the investigation, a file regex blacklist will be added. Additionally only the upload directory needs to be searched. With that php files can easily be excluded. The example configuration is shown in  listing \ref{lst:example:upload} 

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:upload]
    sqlite:
        filename: apache.db
    
    investigator:
        same_config: True
        rules: 
            - name: upload
              greater:
                - meta_modification_time
                - meta_changed_time
                - meta_access_time
            investigations:
                - fileregexblacklist: '.php$'
                  paths: [
                    "/var/www/htdocs/upload/"
                  ]
                  rules:
                    - upload
                    - new_files_ok
                    - deleted_files_ok

\end{lstlisting}

\subsubsection{HTML, CSS, Javascript and images}

The webpage also has some static context, namely HTML, CSS, Javascript and image files. Those are in a directory called `static'. Those files are like the php files, they should not change unless someone creates an update to the page. This is rare. In this static folder only those files are acceptible, in the configuration this results in a blacklist for those file types which is negated. This way files that don't equal these file types are alerted. Additionally the previously used rule named `equal\_but\_accessible' should do the trick to find modified files. An example configuration is shown in listing \ref{lst:example:static} 

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:static]
    sqlite:
        filename: apache.db
    
    investigator:
        same_config: True
        rules: 
            - name: equal_but_accessible
              equal:
                - meta_creation_time
                - meta_creation_time_nano
                - meta_modification_time
                - meta_modification_time_nano
                - meta_changed_time
                - meta_changed_time_nano
                - meta_size
                - path
                - meta_addr
                - name_name
              greater:
                - meta_access_time
        investigations:
            - fileregexblacklist: '.(js|css|png|ts|jp(e)?g|htm(l)?)$'
              blacklist_inverted: true
              paths: [
                "/var/www/htdocs/static/"
              ]
              rules:
                - equal_but_accessible

\end{lstlisting}

\subsubsection{Log directory}

The last directory that is not yet checked is the log directory. Log files usually grow in size until they reach a certain limit. Then they stay static and a new file is created, which then again grows. To create a configuration for that it is important to check the size for growing. Additionally, all the timestamps should also only grow. The file ending could also be checked, if wished this can be copied from the other configurations. One important detail is the `file\_rename\_ok' rule as the rolled over log files might be changed. Also the `new\_files\_ok' rule needs to be added. The example configuration is available in listing \ref{lst:example:log}

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:log]
    sqlite:
        filename: apache.db
    
    investigator:
        same_config: True
        rules: 
            - name: logs
              equal:
                - meta_creation_time
                - path
                - meta_addr
              greater:
                - meta_creation_time_nano
                - meta_modification_time
                - meta_changed_time
                - meta_size
                - meta_access_time
        investigations:
            - paths: [
                "/var/www/htdocs/logs/"
              ]
              rules:
                - logs
                - file_rename_ok
                - new_files_ok

\end{lstlisting}

\subsubsection{Complete configuration}

The partial configurations can then be combined into one bigger configuration. Some rules can be reused, which makes everything a bit easier. The complete configuration is shown in listing \ref{lst:example:complete}.

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:complete]
    sqlite:
        filename: apache.db
    
    scan:
        image_path: /dev/sda1
        scan_paths: 
        [
            "/var/www/htdocs/",
        ]

    investigator:
        same_config: True
        rules: 
            - name: upload
              greater:
                - meta_modification_time
                - meta_changed_time
                - meta_access_time
            - name: equal_but_accessible
              equal:
                - meta_creation_time
                - meta_creation_time_nano
                - meta_modification_time
                - meta_modification_time_nano
                - meta_changed_time
                - meta_changed_time_nano
                - meta_size
                - path
                - meta_addr
                - name_name
              greater:
                - meta_access_time
            - name: logs
              equal:
                - meta_creation_time
                - path
                - meta_addr
              greater:
                - meta_creation_time_nano
                - meta_modification_time
                - meta_changed_time
                - meta_size
                - meta_access_time
        investigations:
            - fileregexwhitelist: '.php$'
              rules:
                - equal_but_accessible
            - fileregexblacklist: '.php$'
              paths: [
                "/var/www/htdocs/upload/"
              ]
              rules:
                - upload
                - new_files_ok
                - deleted_files_ok
            - fileregexblacklist: '.(js|css|png|ts|jp(e)?g|htm(l)?)$'
              blacklist_inverted: true
              paths: [
                "/var/www/htdocs/static/"
              ]
              rules:
                - equal_but_accessible
            - paths: [
                "/var/www/htdocs/logs/"
              ]
              rules:
                - logs
                - file_rename_ok
                - new_files_ok

\end{lstlisting}

\subsection{SSH private keypairs}

Another example in which the \gls{hids} can be used is the tracking of private and public keypairs. Usually they are read when a webserver is started. Afterwards it is cached in the memory of the webserver and the actual files should not be read again. This makes an updated access time a possible intrusion. For this scenario I assume that the keypair is located in the directory `/var/www/.ssh/'. An example configuration is shown in listing \ref{lst:example:keys}.

\begin{lstlisting}[language=yaml, numbers=left, caption=Scanner Configuration, label=lst:example:keys]
    sqlite:
        filename: ssh.db
        
    scan:
        image_path: /dev/sda1
        scan_paths: 
        [
            "/var/www/.ssh/",
        ]

    investigator:
        same_config: True
        rules: 
            - name: equal_not_accessible
              equal:
                - meta_creation_time
                - meta_creation_time_nano
                - meta_modification_time
                - meta_modification_time_nano
                - meta_changed_time
                - meta_changed_time_nano
                - meta_access_time
                - meta_access_time_nano
                - meta_size
                - path
                - meta_addr
                - name_name
        investigations:
            - rules:
                - equal_not_accessible

\end{lstlisting}


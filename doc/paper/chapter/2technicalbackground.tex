
\chapter{Technical Background}

In this chapter I provide some technical introduction to relevant topics. Further information is avaliable in the linked resources.

\section{Definitions}

\subsection{Filesystem}
\label{sec:fs}

\gls{storagemedia} takes many forms. There are the traditional \gls{hdd}, there are newer \gls{ssd}. Both are built based on different assumptions and using different technologies. There are more \gls{storagemedia} like \gls{cd}, \gls{dvd}, \gls{usb} flash drives and more. \gls{storagemedia} operates on blocks of data. One such block is typicaly 512 bytes or 4 \gls{kb}. \cite{bruce:imaging}

An operating system typically needs to store files of data. This is where \glspl{fs} come in. They create a layer of abstraction for the \gls{storagemedia}. A \gls{fs} uses the blocks of the \gls{storagemedia} and stores the files in a data structure called inode. \cite{inode} The \gls{fs} also keeps track of \gls{metadata} like creation time, accessed time, permissions, etc. Which \gls{metadata} is stored depends on the \gls{fs}. \cite{bruce:imaging}

\subsection{Cryptographic Hashing Function}
\label{sec:hashing}

A hash function is generally a function which takes an input of unlimited size and generates an output of a fixed size. Hash functions are used widely in programming and databases to easily access certain data within a datastructure. By design, hash functions have collisions, meaning that multiple inputs generate the same output. This must be true if you consider the unlimited inputsize and limited output size. If there are more inputs than outputs there must be at least one value that is assigned to multiple inputs. For data storage and other usecases this is not a huge problem because collisions can be handled and if the hash function has a good distribution collisions are unlikely. In many systems a hashing function with weak collision resistance is deliberately chosen because it is faster to execute. \cite{hash:noncrypto, hash:slow}

In a cryptographic context this trade off can not be taken. There are two big factors that play into why not. Firstly in cryptography hashes are often used as an assurance that the content of some data has not changed. If collisions are easy to find, the data can be altered in ways that result in the same hash, meaning that the hash no longer fullfils the usecase. Additionally, the potential gain can be big. If a collision can be provoked, even if challenging, data can be changed again. This data could be a legal document or a bank transaction, neither of which we want to change. For those reasons a cryptographic hash function needs to be highly collision resistant. The drawback of collision resistant algorithms over easier hashing functions is operations needed for it, while modern hashing functions are performant and secure, they still take some time for a lot of data. \cite{crypto}

One \gls{hash} is called \gls{sha256}. \gls{sha256} is a standard published by the \gls{nist}. It creates a 256 bit output and has not yet been successfully atacked. \cite{sha} This hashing algorithm is used to make sure that the configuration of this implementation has not changed between multiple runs.


\subsection{HIDS}
\label{sec:def:hids}

A \gls{hids} works by detecting changes on the local host. It does that by looking at files, processes, configuration, logs or other indicators. In this thesis I will only focus on files. It is important to note that the other sources are an important and very valuable source of information. Any of those sources might have \gls{ioc}. Especially running processes and the configuration can hold important data. However, this implementation only covers file based information.

In such a system that finds intrusions via the \gls{fs} most information comes from unexpected changes on the \gls{fs}. Most hosts will not have any changes on the \gls{fs} except for patches. Thus, the easiest approach is to compare the current state of the \gls{fs} to previous ones. If it has changed significantly or in an unexpected way, something foul might be happening. The negative side effect of this approach is the false positives, that come from legitimately changing the host. Those legitimate changes could be new versions of the webpage that is running, new updated configuration or updated keypairs. However, those changes come scheduled and the alerts can then be quickly checked and acknowledged.

A good \gls{hids} should be able to handle such valid changes without much change. Additionally, it should be able to find intrusions reliably and in a timely fashion. Maybe it is to late if the \gls{hids} finds an intrusion a week after it infected the system. To detect changes on the files reliably current \gls{hids} calculate a hash of the files and compares that hash to previous runs. If a \gls{hash} is used, each file will always generate an unique hash which can not be faked. The main drawback of using good \glspl{hash} is that they take a longer time. Some implementations thus use weaker implementations of \gls{hash} or even \gls{nonhash}. The obvious drawback of this approach is that a collision can be generated and such a file can be altered or replaced without the \gls{hids} noticing. 

In the following sections I will present two of the most used \gls{hids}, Tripwire and Aide. They built the main competition of the integration developed in this thesis.

\subsubsection{Tripwire}
\label{sec:tripwire}

In 1992 the first \gls{hids} named tripwire was created and publicly released as a free tool. In 1997 the creator of tripwire then created the company Tripwire Inc. and bought the naming right for Tripwire. The free version was monetized and they released new versions of Tripwire. \cite{Tripwire:Impl,Tripwire:company} Now they mostly market to enterprise and industrial customer and have more products than only one for file integrity. \cite{tripwire}

As it is a comercial product it is hard to see how they work in detail since most of the information is only available to paying customer. 

\subsubsection{AIDE}
\label{sec:aide}

Aide is an \gls{opensource} alternative to tripwire. It was created after tripwire went comercial. \cite{aide:totherescue, aide:github}

When aide is first run, it generates a database as a reference. This database contains all the information for each file that is within a path of interest. Depending on the config it will contain more or less information, including \glspl{hash}. Each subsequent run will then compare the files found to this initially created database. The database needs to be updated manually if needed. It generates a log of all the changes and distributes that per email or similar if configured. Both the configuration and the database are usually stored on the file system that is scanned. \cite{aide, aide:doc}

Aide can compare multiple \glspl{hash} and \glspl{nonhash} and some \gls{metadata}. It runs on many modern unix system \cite{aide} and uses gpg keys to sign their releases. It has a strong comunity behind it, but only offers a \gls{cli} and has no fancy user interface and is written in C. \cite{aide:github} It also contains an extensive configuration covered in section \ref{sec:aide:config}.


\subsection{NIDS}
\label{sec:def:nids}

Compared to a \gls{hids}, a \gls{nids} can be used to detect intrusions over multiple hosts. \gls{nids} are used to analyze anomalies on the network. An \gls{ioc}	might be an unexpected session from a server which usually doesn't communicate with the internet. Also unusually large or frequent trafic might be suspicious. Certain intrusions can be tracked by analyzing the content of the packages. Some intrusions are easier to detect on the network. Especially such ones that extract a lot of data or are very aggressive at spreading within a network. The main advantage here is that multiple sources can be combined on the network level. Another advantage this approach has, is that current \gls{malware} almost always contains some kind of network communication. \cite{Malware:Behaviour,nids}

A \gls{nids} doesn't only have advantages though. Certain kinds of attacks can only be detected on the network with much difficulty. For a corrupted file upload can not really be detected by only checking the network. It is imperative that both types of \gls{ids} are used in conjunction to detect attacks. 

In this thesis \gls{nids} are not in the center. The implementation will not look at network traffic or mimik other \gls{nids} functionality. However, as mentioned above, I highly encourage everyone to use an appropriate \gls{nids} to improve the chance to find an intrusion. 

\subsection{The Sleuth Kit}
\label{sec:tsk}

\gls{tsk} is an \gls{opensource} toolkit used to investigate disk images. It is based on the coroner's toolkit \cite{tct} and contains multiple command line interfaces and an \gls{api} for various purposes. \cite{tsk, tsk:about} It is mainly written in C, runs on Linux, OsX, Windows and more and can be used to analyze many different \glspl{fs}. It is heavily used in forensic investigations to find deleted or corrupted files and for other information gathering on a disk image.

\subsubsection{fls}
\label{sec:fls}

One of those command line tools is fls. It can be used to access directories, files and the attributes of each. With it the directories can be displayed recursively and for each file the attributes can be printed to the console. \cite{tsk:fls} This tool plays a central part in this thesis as it is used to recover all the files and attributes to detect intrusions. On how exactly it is used please refer to section. \ref{sec:Scanner}

\subsection{Python}
\label{sec:python}

Python was the programming language of choice for this product. Python offers many advantages over other languages. Some of those are:

\begin{itemize}
	\item Platform independant
	\item Good community support in forensic community
	\item Active library for \gls{tsk}
	\item Small overhead
	\item Easy for prototyping
	\item Easy to read
\end{itemize}

This decision was not made very lightly. Other programming languages were considered. For more information on those refer to section \ref{sec:decisions:language}.

\subsubsection{pytsk3}
\label{sec:pytsk3}

Pytsk3 is the aforementioned library that creates bindings for python to the \gls{api} of \gls{tsk}. As \gls{tsk} this library is \gls{opensource} and is still active. It is hosted on \gls{github} and offers most of the functionality of the \gls{tsk} \gls{api}. Pytsk3 is used extensively in the scanner part of the implementation. For further information refer to section \ref{sec:Scanner}.

\section{Host based intrusion detection system}
\label{sec:hids}

The main principle behind a \gls{hids} is the detection of changed files. As already discussed in section \ref{sec:def:hids} most tools rely on the calculation of hashes. This is generally a good approach since changes can be found very reliably, however, as already mentioned, it can drastically hinder the performance of the \gls{hids}. Sadly the actual performance lost can not be clearly stated, as it heavily depends on what hardware is in use. But considering the computational overhead of calculating a \gls{hash} it is clear that the time it takes grows with bigger \glspl{fs}. As \gls{storagemedia} has grown from a \gls{mb} to \gls{tb} so has the requirement to store more data. Creating hashes over such big systems is not viable as it can take a long time to create a hash of big amounts of data. \cite{hash:slow, hash:veryslow, hash:speed}

\subsection{Proposed solution for time issue}

In this thesis I propose a different approach. Forget the hashing, and the content of the file. The file attributes suffice to catch an intrusion. The main advantage of not calculating the hashes is the improved speed. The \gls{hids} can thus run way more often. If a conventional \gls{hids} might take several days to complete a run on a \gls{fs} with multiple \gls{tb} of data the proposed approach would maybe take some minutes. It could then be run hourly and find new and changed files within an hour at most. It is possible that the \gls{hids} will miss some changes if the attacker can change all the \gls{metadata} before the system checks the same file again, but this is a risk that has to be taken to gain the opportunity to scan large \gls{fs}. It is also possible to scan highly critical sections of a system with a traditional \gls{hids} and the rest with the proposed solution. This way one has both advantages. The whole system can be checked in a timely fashion with the proposed solution and for certain smaller parts of the system a general \gls{hids} can detect changes by using strong \glspl{hash}.

This solution uses \gls{tsk} via \gls{pytsk} to extract the \gls{fs} \gls{metadata}. The main advantage that this gives is the interoperability with different \glspl{fs}. Additionally, by directly accessing the attributes from the \gls{fs}, no \gls{metadata} is actually changed. The files themselves are never touched. Furthermore, it can also be used to get the files and attributes of an image that has been extracted or of a virtual machine. 

\subsection{Investigation capabilities}
\label{sec:investigation:capabilities}
Another improvement upon existing \gls{hids} proposed is that investigation capabilities need to be built in from the start. Traditional \gls{hids} are good at finding intrusions and alerting them. However, they don't offer support for investigation of the incident. They don't have information bejond what was configured. This makes sense if a lot of the information they gather is through the calculation of \gls{hash}. However, if something was missed in the configuration an investigator can't use the output of those systems to gain further knowledge. They only have one output and nothing further.

This solution stores all the available \gls{metadata} for each scanned file for each run. This way an investigator can use this output to gain more information about how the attacker proceeded. He can look at the changes of permissions, modification of files, even if the alerts might have been ignored. It is also possible to generate a timeline out of this data to form a extended view on what happened when on the \gls{fs}. 

\subsection{Flexibility}

Aide works by comparing runs to one initial execution. This is practical as it will detect one intrusion multiple times. However, it will generate a lot of messages and users are then less likely to take them seriously. Additionally to that, after a legitimate change to the system, Aide will always generate alerts until the initial run is reset. This can lead to undetected intrusions a short time after an upgrade. This might also be the most important window for an intrusion because the update might have created a security risk. Thus, it is possible that an intruder can gain access shortly after an update which will be alerted by Aide, but ignored because of the other false positives.

The proposed system does not have this issue, at least not as strongly. As all the data gets collected for each run anyways, it makes sense to compare each run to the previous. This has the benefit of legitimate changes being adopted into the accepted one run after it has been finished. This results in overall less messages which increases the importance of each. If it is required that the system should always compare against one specific run, this could also easily be done. The system would need to be configured to not check against the latest, but against one specific run. To update this run only the configuration would then need to be changed. 

\section{Scope}

In this project I create a \gls{hids} wich uses \gls{tsk} to detect changes. It will cover the three main changes discussed in section \ref{sec:hids}. This service uses a \gls{sql} database to store the executed runs. It includes an user documentation and this thesis documentation. 

Out of scope are the creation of the timeline mentioned in section \ref{sec:investigation:capabilities}. Also out of scope are extensive alerting functionality and extensive example configurations for commonly used operating systems and tools. Furthermore, any big data analysis of the runs, while very interesting, are also out of scope.


\documentclass[
	a4paper,					% paper format
	10pt,							% fontsize
	twoside,					% double-sided
	openright,				% begin new chapter on right side
	notitlepage,			% use no standard title page
	parskip=half,			% set paragraph skip to half of a line
]{scrreprt}					% KOMA-script report

\raggedbottom
\KOMAoptions{cleardoublepage=plain}			% Add header and footer on blank pages
\usepackage[utf8]{inputenc}  							% Unix/Linux - load extended character set (ISO 8859-1)

\usepackage{csquotes}
\usepackage[hidelinks]{hyperref}
\usepackage{color}

% Code Segments
\usepackage{listings}

\usepackage[english]{babel}										% english hyphenation
%\usepackage[ansinew]{inputenc}  							% Windows - load extended character set (ISO 8859-1)
\usepackage{fancyhdr}													% simple manipulation of header and footer
\usepackage{etoolbox}													% color manipulation of header and footer
\usepackage{graphicx}                      		% integration of images
\usepackage{float}														% floating objects
\usepackage{caption}													% for captions of figures and tables
\usepackage{booktabs}													% package for nicer tables
\usepackage{tocvsec2}													% provides means of controlling the sectional numbering
\usepackage{tabularx}
%---------------------------------------------------------------------------

% Set up page dimension
%---------------------------------------------------------------------------
\usepackage{geometry}
\geometry{
	a4paper,
	left=28mm,
	right=15mm,
	top=30mm,
	headheight=20mm,
	headsep=10mm,
	textheight=242mm,
	footskip=15mm
}


% Compact Itemize:
%---------------------------------------------------------------------------
\newenvironment{compactitemize}
{ \begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  }
\newenvironment{compactenumerate}
{ \begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{enumerate}  				 }

\RequirePackage{color}                          % Color (not xcolor!)
\definecolor{linkblue}{rgb}{0,0,0.8}            % Standard
\definecolor{darkblue}{rgb}{0,0.08,0.45}        % Dark blue
\definecolor{bfhgrey}{rgb}{0.41,0.49,0.57}      % BFH grey
\definecolor{linkcolor}{rgb}{0,0,0.8}  
\definecolor{darkblue}{rgb}{0,.2,.4}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{brown}{rgb}{.4,.4,.3}
\definecolor{darkred}{rgb}{.6,0,0}
\definecolor{linenumbergray}{rgb}{.6,.6,.6}   			% Blue for the web- and cd-version!
%\definecolor{linkcolor}{rgb}{0,0,0}        			% Black for the print-version!


\usepackage{colortbl}
\usepackage{longtable}
\usepackage{lscape}


\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}



% Sequence Diagram
\usepackage{geometry}
\usepackage{pgf-umlsd}
\usetikzlibrary{calc}

% Glossary
\usepackage[toc,section=section, acronym]{glossaries}
\makeglossaries
\input{glossary.tex}



\usepackage{polyglossia}
\setdefaultlanguage{english}
\usepackage[backend=biber, style=ieee]{biblatex}
\addbibresource{thesis.bib}
\usepackage{graphicx}

\usepackage{pgfgantt}

\definecolor{ganttplanned}{RGB}{0,80,200}
\definecolor{ganttplannedopt}{RGB}{50,50,50}
\definecolor{ganttactual}{RGB}{234,187,0}
\definecolor{ganttunplanned}{RGB}{153,0,0}

\newganttchartelement*{plannedmilestone}{%
  plannedmilestone/.style={
	shape=ganttmilestone,
	inner sep=0pt,
	draw=ganttplanned!50!black,
	top color=white,	
	bottom color=ganttplanned!50% 
  },
  plannedmilestone label text=\strut#1,
  plannedmilestone label font=\footnotesize,
  plannedmilestone label node/.style={%
	anchor=east, font=\ganttvalueof{plannedmilestone label font}%
  },%
  plannedmilestone inline label anchor=center,%
  plannedmilestone inline label node/.style={%
	anchor=south, font=\ganttvalueof{plannedmilestone label font}%
  },%
  plannedmilestone left shift = .6,
  plannedmilestone right shift = .4,
  plannedmilestone top shift = .05,
  plannedmilestone height = .6
}
\newganttchartelement*{actualmilestone}{%
  actualmilestone/.style={
	shape=ganttmilestone,
	inner sep=0pt,
	draw=ganttactual!50!black,
	top color=white,	
	bottom color=ganttactual!50% 
  },
  actualmilestone label text=\strut#1,
  actualmilestone label font=\footnotesize,
  actualmilestone label node/.style={%
	anchor=east, font=\ganttvalueof{actualmilestone label font}%
  },%
  actualmilestone inline label anchor=center,%
  actualmilestone inline label node/.style={%
	anchor=south, font=\ganttvalueof{actualmilestone label font}%
  },%
  actualmilestone left shift = .6,
  actualmilestone right shift = .4,
  actualmilestone top shift = .35,
  actualmilestone height = .6
}





\begin{document}
\title{Alternative scalable HIDS with investigation capability}
\date{\today} 
\author{ Julian Stampfli (\texttt{stamj3@bfh.ch}) }
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents
\clearpage

\chapter{Introduction}

An \gls{ids} is used to protect a computer from \gls{malware} attacks. It does so by tracking and evaluating activity form one or many hosts. The \gls{ids} then tries to find \glspl{anomaly} usually by comparing the activity to some type of configuration which often contains some form of blacklist or whitelist. The \glspl{anomaly} are then alerted or logged to some framework. The process of intrusion detection is generally split into a host based part with \gls{hids} and a network based part with \gls{nids}. \gls{nids} are used to detect unusual behaviour of the network. Examples include communication from hosts which usually don't comunicate. \gls{hids} on the other hand are used to detect \glspl{anomaly} on a host. This is done by detecting changes in the way processes are used or when the \gls{fs} is changed. Both types of \gls{ids} have different advantages and they should be used in conjunction for best results. \cite{needed}

This Thesis is about writing of a \gls{hids} that operates on the \gls{fs}. As already mentioned a \gls{hids} operates on the host machine and detects \glspl{anomaly} by comparing resources available on the host. For detecting changes to the \gls{fs} a \gls{hids} usually generates \glspl{hash} and compares them to previous calculations. If the \gls{hash} changes, then the file has been altered. If this alteration is detected as an \gls{anomaly} it will be alerted. This approach has one weakness. The caclulation of a \gls{hash} takes time. \cite{hash:slow} This is historically not relevant as it is efficient enough that the entire \gls{fs} could be hashed in a small amount of time. But storage media grew and with it the amount of data on a server. \cite{bruce:imaging} With that the calculation of \glspl{hash} needs more time and traditional \gls{hids} can't scan big systems within a valuable amount of time anymore. Finding anomalies based on \gls{metadata} is faster, because the files don't need to be parsed and the size of them doesn't matter. Thus, such a \gls{hids} can be run frequently and with that \glspl{intrusion} can be detected faster, which is essential for protection. \cite{inode}

The \gls{hids} written in this thesis tries to gain another advantage. \gls{hids} are used to protect against \glspl{intrusion}. They don't offer much support in \gls{investigation} once an \gls{intrusion} happend. Those \gls{investigation} capabilities are built in this implementation. 

\section{Drawbacks}

This implementation doesn't calculate \glspl{hash}, changes within a file can thus be hidden from the \gls{hids} if the intrusion adjusts all the \gls{metadata} of the changed files. For further information on this attack and how to mitigate it please see section \ref{sec:attack_scenarios}.

\chapter{Technical Background}

In this chapter I provide some technical introduction to relevant topics. Further information is avaliable in the linked resources.

\section{Filesystem}
\label{sec:fs}

\gls{storagemedia} takes many forms. There are the traditional \gls{hdd}, there are newer \gls{ssd}. Both are built based on different assumptions and using different technologies. There are more \gls{storagemedia} like \gls{cd}, \gls{dvd}, \gls{usb} flash drives and more. \gls{storagemedia} operates on blocks of data. One such block is typicaly 512 bytes or 4 \gls{kb}. \cite{bruce:imaging}

An operating system typically needs to store files of data. This is where \glspl{fs} come in. They create a layer of abstraction for the \gls{storagemedia}. A \gls{fs} uses the blocks of the \gls{storagemedia} and stores the files in a data structure called inode. \cite{inode} The \gls{fs} also keeps track of \gls{metadata} like creation time, accessed time, permissions, etc. Which \gls{metadata} is stored depends on the \gls{fs}. \cite{bruce:imaging}

\section{\gls{hash}}
\label{sec:hashing}



\section{HIDS}

In this section I will present two of the most used \gls{hids}, Tripwire and Aide. They built the main competition of the integration developed in this thesis.

\subsection{Tripwire}

In 1992 the first \gls{hids} named tripwire was created and publicly released as a free tool. In 1997 the creator of tripwire then created the company Tripwire Inc. and bought the naming right for Tripwire. The free version was monetized and they released new versions of Tripwire. \cite{Tripwire:Impl,Tripwire:company} Now they mostly market to enterprise and industrial customer and have more products than only one for file integrity. \cite{tripwire}

As it is a comercial product it is hard to see how they work in detail since most of the information is only available to paying customer. 

\subsection{AIDE}

Aide is an \gls{opensource} alternative to tripwire. It was created after tripwire went comercial. \cite{aide:totherescue, aide:github}

When aide is first run, it generates a database as a reference. This database contains all the information for each file that is within a path of interest. Depending on the config it will contain more or less information, including \glspl{hash}. Each subsequent run will then compare the files found to this initially created database. The database needs to be updated manually if needed. It generates a log of all the changes and distributes that per email or similar if configured. Both the configuration and the database are usually stored on the file system that is scanned. \cite{aide, aide:doc}

Aide can compare multiple \glspl{hash}, some non \glspl{hash} and some \gls{metadata}. It claims to run on any modern unix system \cite{aide} and uses gpg keys to sign their releases. Since it is an \gls{opensource} project it has a good comunity behind it. It only offers a \gls{cli} and has no fancy user interface and it is written in the programming language C. \cite{aide:github}

Aide offers a good starting point for my system. I took several 

\section{TSK}

\section{Programming Language}

\section{pytsk3}

\section{Scope}

\chapter{Results}

\section{System Architecture}

\subsection{Scanner}

\subsection{Detection}

\subsection{Configuration}

\subsection{Database}

\section{Security}

\subsection{Limitations}

\subsection{Attack Scenarios}
\label{sec:attack_scenarios}

\section{Application Flow}

\chapter{Discussion}

\section{Future Work}

\section{Conclusion}

\chapter{Journal}

\chapter{Implementation Details}

\chapter{User Documentation}

\chapter{Project Management}

\section{Goal}
\label{apdx-sec:goal}
Before the start of the project the following main goal was defined:

Building of an \gls{hids} that detects unauthorized or unusual behaviour on the file system. Compared to traditional \gls{hids} file system integrity checking, it should scale with a lot of data and have the possibility to be used for investigation (retain historic data) built in from the start.

\subsection{Sub goals}

From this primary goal, the following sub goals were defined. 

\subsubsection{Scanning}
The system is capable of scanning the file system for certain properties. The search is done by leveraging the sleuthkit tools. Thus the system is capable of interpreting the results from sleuthkit. It will further analyze them and decide on what to do with the results. Especially importance is given to the finding of differences.

\subsubsection{Recording}
The system records all findings. Including new, changed and deleted files in comparison to an earlier point in time. This recording enables the use of investigation as the evolution of the data can be viewed at any time. This data can also be used for machine learning algorithms to detect anomalies that are out of the scope of this thesis. 

\subsubsection{Evaluation}
The system is capable of evaluating the results by applying predefined rules. Those rules can be adjusted by configuring the system.

It is thinkable that the system analyzes the recordings and makes decisions based on the historical behavior of the specific host and behavior from different similar hosts. This approach is not part of this thesis as it requires much historical data that is not present at the time of this thesis. 

\subsubsection{Alerting}
The system is capable of being run continuously. This capability enables it to find anomalies automatically. The system can report those anomalies by creating alerts. It allows configuration of these alerts.

\subsubsection{Scaling}
The run of the system on a big file system completes in an appropriate amount of time. This speed allows the finding of anomalies that appeared recently. Additionally, it allows the storing of more states of the system which results in a her probability of capturing short-lived anomalies for future investigations. 

\section{Workpackages}

From those goals the workpackages in table \ref{tab:workpackages} were defined. For a better overview they are assigned to categories. The categories are Architecture, Implementation, Validation and Administrative. Architecture is about defining how the system will look like and how it should work. Implementation is the effective implementation work for getting the system to run, this includes configuration and coding. Validation is about testing of the system. Administrative is everything that deals with project management and other workpackages that don't directly influence the system but need to be done.

The ID is a combination of the first letter of the category and a unique index. Administrative is shortened to D due to the conflict with Architecture.

The priority is a value of high, medium and low. 

The workpackages are chrononically ordered. Meaning they should be worked on in approximately the order that they are given. 

\begin{table}[h!]
  \begin{center}
    \caption{Workpackages}
    \label{tab:workpackages}
    \begin{tabular}{c|l|c|l}
      \textbf{ID} & \textbf{Short description} & \textbf{Prio} & \textbf{Category} \\
      \hline
      D00 & Setting up \LaTeX -document & h & Administrative \\
      D01 & Define workpackages and set deadlines & h & Administrative \\
			A00 & Research other \gls{hids} and the sleuthkit tools & h & Architecture \\
			A01 & Decide on a Programming Language & h & Architecture \\
			I00 & Setup the developer environment & h & Implementation \\
			I01 & Add the ability to scan the whole system using sleuthkit & h & Implementation \\
			A02 & Decide which database connectors should be used & h & Architecture \\
			I02 & Add one database connector & h & Implementation \\
			I03 & Implement a recording functionality & h & Implementation \\
			A03 & Decide how the rules should be defined & h & Architecture \\
			I04 & Add template rules and ability to parse them & h & Implementation \\
			I05 & Add functionality to parse output according to rules & h & Implementation \\
			V00 & Verify that the system runs on a big file system & h & Validation \\
			I06 & Add functionality of repeated scans & m & Implementation \\
			A04 & Define which alerting methods make sense & m & Architecture \\ 
			I07 & Add alerting functionality using one method & m & Implementation \\
			V01 & Verify the functionality of the software by changing the system & h & Validation \\
			V02 & Verify the functionality of the software by running it on an infected system & m & Validation \\
			V03 & Verify the alerting of the software by running it on an infectable system & m & Validation \\
			I08 & Add multiple database connectors to different systems & m & Implementation \\
			I09 & Add multiple alerting methods & m & Implementation \\
			A05 & Define how to protect system and configuration from tampering & l & Architecture \\
			I10 & Implement software hardening & l & Implementation \\
			D02 & Finish user documentation & m & Administrative \\
			D03 & Finish project documentation & h & Administrative \\ 
			D04 & Create project presentation & h & Administrative \\
			D05 & Create project poster & m & Administrative \\
			D06 & Create project video & l & Administrative \\
    \end{tabular}
  \end{center}
\end{table}

\section{Planning}

For the planning of this project the following milestones were created. Each coveres multiple workpackages. The mapping can be seen in table \ref{tab:milestones}. The milestones can also be seen in figure \ref{apdx-fig:milestones}. There they are displayed with an assumed and actual finish date.



\begin{table}[h!]
  \begin{center}
    \caption{Milestones}
    \label{tab:milestones}
    \begin{tabular}{c|l|c|l}
      \textbf{ID} & \textbf{Short description} & \textbf{Workpackages} \\
      \hline
			00 & Setup & D00, D01, A00, A01, I00 \\
			01 & Initial functionality & A02, I01, I02, I03 \\
			02 & Rules & A03, I04, I05, V00 \\
			03 & Alerting & A04, I06, I07 \\
			04 & Exhaustive testing & V01, V02, V03 \\
			05 & Usability & I08, I09, D02 \\
			06 & Software Hardening & A05, I10 \\
			07 & Presentation & D02, D03, D04, D05, D06 \\
    \end{tabular}
  \end{center}
\end{table}


\begin{figure}[H]
	\begin{ganttchart}[
		hgrid,
		vgrid,
		x unit=7mm,
		y unit chart=10mm,
		milestone label font = \footnotesize
	]{1}{17}
	\gantttitle{2019}{17}\\
	\gantttitlelist{1,...,17}{1}\\
	
	\ganttplannedmilestone{Setup}{4}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Initial functionality}{5}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Rules}{7}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Alerting}{8}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Exhaustive testing}{10}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Usability}{13}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Software Hardening}{15}
	\ganttactualmilestone{}{0}\\
	\ganttplannedmilestone{Presentation}{17}
	\ganttactualmilestone{}{0}
	\end{ganttchart}
	\caption{Milestones}
	\label{apdx-fig:milestones}
	\end{figure}

\section{Meetings}

\subsection{Template}

Hi Bruce,

Next Meeting:

Discussions:

Next Steps:

Julian


\newpage



\clearpage


\printglossaries

\clearpage

%% Print the bibibliography and add the section to the table of content
\printbibliography[heading=bibintoc]

%% Print the bibibliography and add the section to the table of content

\end{document}
